# Руководство по бенчмаркам производительности

## Обзор

Создан набор бенчмарков для измерения производительности критических компонентов Thalex Rust SDK. Бенчмарки используют библиотеку `criterion`, которая предоставляет статистически значимые результаты и автоматически генерирует отчеты.

## Установка зависимостей

Зависимости уже добавлены в `Cargo.toml`:
- `criterion` - библиотека для бенчмарков
- `tokio-test` - утилиты для тестирования асинхронного кода

## Запуск бенчмарков

### Запуск всех бенчмарков
```bash
cargo bench
```

### Запуск конкретного бенчмарка
```bash
cargo bench --bench json_parsing
cargo bench --bench handle_incoming
cargo bench --bench mutex_contention
cargo bench --bench subscription_throughput
```

### Запуск с фильтром
```bash
cargo bench --bench json_parsing -- "full_parse"
```

## Описание бенчмарков

### 1. `benchmarks/json_parsing.rs`
Измеряет производительность JSON парсинга - критического пути в обработке сообщений.

**Тестируемые сценарии:**
- Полный парсинг RPC ответов (маленькие сообщения)
- Полный парсинг ticker сообщений (средние сообщения)
- Полный парсинг больших сообщений
- Быстрая проверка наличия ключей без полного парсинга
- Условный парсинг (только после проверки ключа)

**Метрики:**
- Время парсинга на сообщение
- Сравнение полного парсинга vs быстрой проверки

**Использование результатов:**
- Определить, стоит ли использовать быструю проверку ключей перед полным парсингом
- Измерить влияние размера сообщения на производительность

### 2. `benchmarks/mutex_contention.rs`
Измеряет производительность блокировок Mutex при различной нагрузке.

**Тестируемые сценарии:**
- Write-heavy: вставка и удаление элементов
- Read-heavy: множественные чтения
- Смешанная нагрузка: конкурентный доступ из нескольких задач

**Метрики:**
- Время удержания блокировки
- Throughput операций при разном количестве элементов
- Влияние конкуренции на производительность

**Использование результатов:**
- Оценить необходимость замены Mutex на DashMap или RwLock
- Определить оптимальную структуру данных для subscriptions и pending_requests

### 3. `benchmarks/handle_incoming.rs`
Измеряет производительность функции `handle_incoming` - основного обработчика сообщений.

**Тестируемые сценарии:**
- Обработка RPC ответов с пустыми структурами
- Обработка RPC ответов с pending запросами
- Обработка ticker сообщений без подписки
- Обработка ticker сообщений с подпиской
- Обработка с множеством подписок (1, 10, 50, 100)
- Обработка с множеством pending запросов (1, 10, 50, 100)

**Метрики:**
- Время обработки одного сообщения
- Влияние размера структур данных на производительность
- Деградация производительности при росте количества элементов

**Использование результатов:**
- Выявить узкие места в обработке сообщений
- Определить оптимальные размеры структур данных
- Оценить влияние блокировок на latency

### 4. `benchmarks/subscription_throughput.rs`
Измеряет throughput подписок - количество сообщений, обрабатываемых в секунду.

**Тестируемые сценарии:**
- Обработка одного сообщения
- Последовательная обработка 100 и 1000 сообщений
- Конкурентная обработка с разным количеством каналов (1, 5, 10, 20)
- Измерение реального throughput

**Метрики:**
- Сообщений в секунду
- Latency обработки
- Влияние конкуренции на throughput

**Использование результатов:**
- Определить максимальный throughput системы
- Оценить, справится ли система с высокой частотой сообщений (например, 100ms ticker)
- Выявить узкие места при масштабировании

## Интерпретация результатов

### Criterion автоматически предоставляет:
1. **Среднее время выполнения** - основная метрика
2. **Стандартное отклонение** - показывает стабильность результатов
3. **Изменение по сравнению с baseline** - полезно при сравнении оптимизаций
4. **HTML отчеты** - визуализация результатов в `target/criterion/`

### Ключевые метрики для мониторинга:

1. **Latency (задержка)**
   - Для ticker с задержкой 100ms, обработка должна быть < 1ms
   - Для RPC запросов, обработка должна быть < 10ms

2. **Throughput (пропускная способность)**
   - Минимум 1000 сообщений/сек для одного канала
   - Масштабирование до 10,000+ сообщений/сек для множества каналов

3. **Масштабируемость**
   - Производительность не должна деградировать линейно с ростом количества подписок
   - Конкуренция за блокировки не должна создавать узкие места

## Сравнение до и после оптимизаций

### Рекомендуемый workflow:

1. **Baseline измерение:**
   ```bash
   cargo bench --bench handle_incoming > baseline.txt
   ```

2. **Внедрение оптимизации**

3. **Измерение после оптимизации:**
   ```bash
   cargo bench --bench handle_incoming > optimized.txt
   ```

4. **Сравнение:**
   Criterion автоматически сравнивает результаты, если запускать бенчмарки в той же сессии.

### Использование Criterion для сравнения:
```bash
# Criterion автоматически сохраняет результаты в target/criterion/
# При повторном запуске сравнивает с предыдущими результатами
cargo bench --bench handle_incoming
```

## Рекомендации по использованию

1. **Запускайте бенчмарки на стабильной системе**
   - Закройте другие приложения
   - Используйте фиксированную частоту CPU (если возможно)
   - Запускайте несколько раз для получения стабильных результатов

2. **Мониторьте системные ресурсы**
   - CPU usage
   - Memory usage
   - Context switches

3. **Тестируйте реалистичные сценарии**
   - Используйте реальные размеры сообщений
   - Тестируйте с типичным количеством подписок (10-50)
   - Учитывайте реальную частоту сообщений

4. **Документируйте результаты**
   - Сохраняйте результаты бенчмарков
   - Отслеживайте изменения производительности
   - Связывайте оптимизации с метриками

## Дополнительные метрики

Для более глубокого анализа можно добавить:

1. **Профилирование с perf:**
   ```bash
   perf record --call-graph dwarf cargo bench --bench handle_incoming
   perf report
   ```

2. **Анализ аллокаций с dhat:**
   ```toml
   [dev-dependencies]
   dhat = "0.3"
   ```

3. **Мониторинг блокировок:**
   Добавить логирование времени удержания блокировок в коде.

## Примеры интерпретации

### Хороший результат:
```
handle_incoming/ticker_with_subscription
                        time:   [1.2345 µs 1.2456 µs 1.2567 µs]
```
- Latency < 2µs - отлично для 100ms ticker
- Стабильные результаты (маленькое стандартное отклонение)

### Проблемный результат:
```
handle_incoming/ticker_many_subscriptions/100
                        time:   [50.123 µs 55.456 µs 60.789 µs]
```
- Latency > 50µs - может быть проблемой при высокой частоте
- Большое стандартное отклонение - нестабильная производительность
- **Действие:** Рассмотреть оптимизацию блокировок

### Улучшение после оптимизации:
```
handle_incoming/ticker_many_subscriptions/100
                        time:   [5.123 µs 5.456 µs 5.789 µs]
                        change: [-89.2% -90.1% -91.0%] (p = 0.00 < 0.05)
```
- Значительное улучшение (> 80%)
- Статистически значимое (p < 0.05)
- **Вывод:** Оптимизация успешна

