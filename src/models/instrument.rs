/*
 * Websocket Subscription Schemas
 *
 * Schema definitions Websocket API subscriptions for Thalex exchange.
 *
 * The version of the OpenAPI document: 1.0.0
 *
 * Generated by: https://openapi-generator.tech
 */

use crate::models;
use serde::{Deserialize, Serialize};

#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct Instrument {
    #[serde(rename = "instrument_name", skip_serializing_if = "Option::is_none")]
    pub instrument_name: Option<String>,
    /// E.g. \"FBTCUSD\", \"OBTCUSD\".
    #[serde(rename = "product", skip_serializing_if = "Option::is_none")]
    pub product: Option<String>,
    /// Price alignment.
    #[serde(rename = "tick_size", skip_serializing_if = "Option::is_none")]
    pub tick_size: Option<rust_decimal::Decimal>,
    /// Amount alignment.
    #[serde(rename = "volume_tick_size", skip_serializing_if = "Option::is_none")]
    pub volume_tick_size: Option<rust_decimal::Decimal>,
    /// Minimum order amount for this instrument. This value is always greater or equal to `volume_tick_size`.  If this value is greater than `volume_tick_size`, it is not possible to insert an order of a smaller amount, or amend an existing order to a smaller amount. However, orders in the books can have smaller remaining amounts as they get partially filled, down to the minimum of `volume_tick_size`.
    #[serde(rename = "min_order_amount", skip_serializing_if = "Option::is_none")]
    pub min_order_amount: Option<rust_decimal::Decimal>,
    /// Related index, e.g. \"BTCUSD\".
    #[serde(rename = "underlying", skip_serializing_if = "Option::is_none")]
    pub underlying: Option<String>,
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub r#type: Option<models::TypeEnum>,
    #[serde(rename = "option_type", skip_serializing_if = "Option::is_none")]
    pub option_type: Option<models::OptionTypeEnum>,
    /// Expiration date in ISO format (YYYY-mm-dd).
    #[serde(rename = "expiry_date", skip_serializing_if = "Option::is_none")]
    pub expiry_date: Option<String>,
    /// Expiration time as Unix timestamp (seconds).
    #[serde(
        rename = "expiration_timestamp",
        skip_serializing_if = "Option::is_none"
    )]
    pub expiration_timestamp: Option<i32>,
    /// Strike price of option.
    #[serde(rename = "strike_price", skip_serializing_if = "Option::is_none")]
    pub strike_price: Option<rust_decimal::Decimal>,
    /// Base currency for pricing (i.e. USD).
    #[serde(rename = "base_currency", skip_serializing_if = "Option::is_none")]
    pub base_currency: Option<String>,
    /// For combinations, array of objects with `instrument_name` and `quantity`.
    #[serde(rename = "legs", skip_serializing_if = "Option::is_none")]
    pub legs: Option<Vec<models::InstrumentLegsInner>>,
    /// Creation time (Unix timestamp).
    #[serde(rename = "create_time", skip_serializing_if = "Option::is_none")]
    pub create_time: Option<rust_decimal::Decimal>,
    /// For expired instruments, the final settlement price.
    #[serde(rename = "settlement_price", skip_serializing_if = "Option::is_none")]
    pub settlement_price: Option<rust_decimal::Decimal>,
    /// For expired instruments, the underlying delivery price.
    #[serde(
        rename = "settlement_index_price",
        skip_serializing_if = "Option::is_none"
    )]
    pub settlement_index_price: Option<rust_decimal::Decimal>,
}

impl Instrument {
    pub fn new() -> Instrument {
        Instrument {
            instrument_name: None,
            product: None,
            tick_size: None,
            volume_tick_size: None,
            min_order_amount: None,
            underlying: None,
            r#type: None,
            option_type: None,
            expiry_date: None,
            expiration_timestamp: None,
            strike_price: None,
            base_currency: None,
            legs: None,
            create_time: None,
            settlement_price: None,
            settlement_index_price: None,
        }
    }
}
