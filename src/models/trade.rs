/*
 * Thalex API Description
 *
 * Talex API documentation
 *
 * The version of the OpenAPI document: 2.49.0
 *
 * Generated by: https://openapi-generator.tech
 */

use crate::models;
use serde::{Deserialize, Serialize};

#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct Trade {
    /// Type of the trade.  Note: as of API v2.31.0 we have stopped representing futures-style settlements as trades of `daily_mark` type. You might still get such trades in the history, but no new trades of `daily_mark` type will be created. To get information about daily marks, use `private/daily_mark_history` API endpoint.
    #[serde(rename = "trade_type", skip_serializing_if = "Option::is_none")]
    pub trade_type: Option<TradeType>,
    #[serde(rename = "trade_id", skip_serializing_if = "Option::is_none")]
    pub trade_id: Option<String>,
    #[serde(rename = "order_id", skip_serializing_if = "Option::is_none")]
    pub order_id: Option<String>,
    #[serde(rename = "instrument_name", skip_serializing_if = "Option::is_none")]
    pub instrument_name: Option<String>,
    #[serde(rename = "direction", skip_serializing_if = "Option::is_none")]
    pub direction: Option<Direction>,
    /// Trade price.
    #[serde(rename = "price", skip_serializing_if = "Option::is_none")]
    pub price: Option<f64>,
    /// Traded amount.
    #[serde(rename = "amount", skip_serializing_if = "Option::is_none")]
    pub amount: Option<f64>,
    /// User label.
    #[serde(rename = "label", skip_serializing_if = "Option::is_none")]
    pub label: Option<String>,
    /// Time of trade (Unix timestamp).
    #[serde(rename = "time", skip_serializing_if = "Option::is_none")]
    pub time: Option<f64>,
    /// Position in this instrument right after the trade.
    #[serde(rename = "position_after", skip_serializing_if = "Option::is_none")]
    pub position_after: Option<f64>,
    /// Session realised P&L for this instrument right after the trade.
    #[serde(
        rename = "session_realised_after",
        skip_serializing_if = "Option::is_none"
    )]
    pub session_realised_after: Option<f64>,
    /// If trade closed a position, the positional P&L that was realised.
    #[serde(rename = "position_pnl", skip_serializing_if = "Option::is_none")]
    pub position_pnl: Option<f64>,
    /// If trade closed a position in a perpetual, the funding P&L that was realised.
    #[serde(
        rename = "perpetual_funding_pnl",
        skip_serializing_if = "Option::is_none"
    )]
    pub perpetual_funding_pnl: Option<f64>,
    /// The fee paid for this trade.
    #[serde(rename = "fee", skip_serializing_if = "Option::is_none")]
    pub fee: Option<f64>,
    /// The relevant index at time of trade.
    #[serde(rename = "index", skip_serializing_if = "Option::is_none")]
    pub index: Option<f64>,
    /// The fee rate applied to calculate the fee.
    #[serde(rename = "fee_rate", skip_serializing_if = "Option::is_none")]
    pub fee_rate: Option<f64>,
    /// The perpetual funding mark as applied to the trade (see `Ticker`).
    #[serde(rename = "funding_mark", skip_serializing_if = "Option::is_none")]
    pub funding_mark: Option<f64>,
    /// Fee paid in case of liquidation.
    #[serde(rename = "liquidation_fee", skip_serializing_if = "Option::is_none")]
    pub liquidation_fee: Option<f64>,
    /// Client order reference as set in related order.
    #[serde(rename = "client_order_id", skip_serializing_if = "Option::is_none")]
    pub client_order_id: Option<f64>,
    /// Maker (trade on book order) or taker (trade on new order), if applicable.
    #[serde(rename = "maker_taker", skip_serializing_if = "Option::is_none")]
    pub maker_taker: Option<MakerTaker>,
    /// If the trade was made by a bot, the ID of that bot. Otherwise omitted.
    #[serde(rename = "bot_id", skip_serializing_if = "Option::is_none")]
    pub bot_id: Option<String>,
    /// Index of a leg on which the trade happened for combination orders. Zero for single-leg orders.  For combination orders the direction of the trade is defined by the direction of the order and the sign of the leg quantity.
    #[serde(rename = "leg_index", skip_serializing_if = "Option::is_none")]
    pub leg_index: Option<f64>,
}

impl Trade {
    pub fn new() -> Trade {
        Trade {
            trade_type: None,
            trade_id: None,
            order_id: None,
            instrument_name: None,
            direction: None,
            price: None,
            amount: None,
            label: None,
            time: None,
            position_after: None,
            session_realised_after: None,
            position_pnl: None,
            perpetual_funding_pnl: None,
            fee: None,
            index: None,
            fee_rate: None,
            funding_mark: None,
            liquidation_fee: None,
            client_order_id: None,
            maker_taker: None,
            bot_id: None,
            leg_index: None,
        }
    }
}
/// Type of the trade.  Note: as of API v2.31.0 we have stopped representing futures-style settlements as trades of `daily_mark` type. You might still get such trades in the history, but no new trades of `daily_mark` type will be created. To get information about daily marks, use `private/daily_mark_history` API endpoint.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize, )]
pub enum TradeType {
    #[serde(rename = "normal")]
    Normal,
    #[serde(rename = "block")]
    Block,
    #[serde(rename = "combo")]
    Combo,
    #[serde(rename = "amend")]
    Amend,
    #[serde(rename = "delete")]
    Delete,
    #[serde(rename = "internal_transfer")]
    InternalTransfer,
    #[serde(rename = "expiration")]
    Expiration,
    #[serde(rename = "daily_mark")]
    DailyMark,
    #[serde(rename = "rfq")]
    Rfq,
    #[serde(rename = "liquidation")]
    Liquidation,
}

impl Default for TradeType {
    fn default() -> TradeType {
        Self::Normal
    }
}
///
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum Direction {
    #[serde(rename = "buy")]
    Buy,
    #[serde(rename = "sell")]
    Sell,
}

impl Default for Direction {
    fn default() -> Direction {
        Self::Buy
    }
}
/// Maker (trade on book order) or taker (trade on new order), if applicable.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum MakerTaker {
    #[serde(rename = "maker")]
    Maker,
    #[serde(rename = "taker")]
    Taker,
}

impl Default for MakerTaker {
    fn default() -> MakerTaker {
        Self::Maker
    }
}
